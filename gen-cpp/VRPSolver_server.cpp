// This autogenerated skeleton file illustrates how to build a server.
// You should copy it to another filename to avoid overwriting it.

#include "VRPSolver.h"


#include <thrift/protocol/TBinaryProtocol.h>
#include <thrift/server/TSimpleServer.h>
#include <thrift/transport/TServerSocket.h>
#include <thrift/transport/TBufferTransports.h>
#include <thrift/protocol/TBinaryProtocol.h>
#include <thrift/server/TSimpleServer.h>
#include <thrift/server/TNonblockingServer.h>
#include "../main.h"
#include "../utils.h"
#include "base/commandlineflags.h"

using namespace ::apache::thrift;
using namespace ::apache::thrift::protocol;
using namespace ::apache::thrift::transport;
using namespace ::apache::thrift::server;
using namespace ::apache::thrift::concurrency;
using boost::shared_ptr;

class VRPSolverHandler : virtual public VRPSolverIf {
 public:
  VRPSolverHandler() {
    // Your initialization goes here
  }

  void solveCVRP(std::vector<std::vector<int64_t> > & _return, const std::vector<std::vector<int64_t> > & vec, const std::vector<int64_t> & demands, const std::vector<int64_t> & v_caps, const int64_t lns, const int64_t tm) {


    // Utils utils;

    // std::vector<std::vector<int64>> tempVec = utils.cast2dList(vec);
    // std::vector<int64> dem = utils.castList(demands);
    // std::vector<int64> veh_caps = utils.castList(v_caps);
    // operations_research::Matrix matrix(tempVec, dem, veh_caps);
    // operations_research::CVRPTWSolver vrpSolver;

    // std::vector<std::vector<int64>> cvrp_result = vrpSolver.SolveCVRP(matrix, veh_caps.size());

    // for(int i=0; i< cvrp_result.size(); i++) {

    //   _return.push_back(std::vector<int64_t>(0,0));
    //   for (int j = 0; j < cvrp_result[i].size(); j++){

    //     _return[i].push_back((int64_t) cvrp_result[i][j]);
    //   }
    // }

    int size = vec.size();
    int demandSize  = demands.size();

    std::vector<long long int> v2 (size, 0);
    std::vector<long long int> dem (demandSize, 0);
    std::vector<long long int> veh_caps(v_caps.size(),0);

    std::vector<std::vector<long long int>> tempVec(size, v2);

    for(int i=0; i< tempVec.size(); i++) {
      for (int j=0;j<tempVec[i].size(); j++){

        tempVec[i][j] = (long long int) vec[i][j];
        // std::cout << tempVec[i][j] << " ";
      }
      // std::cout << std::endl;
    }


    for(int i=0; i< demandSize; i++) {

      dem[i] = demands[i];
    }


    for(int i=0; i< v_caps.size(); i++) {

      veh_caps[i] = v_caps[i];
    }






    operations_research::Matrix matrix(tempVec, dem, veh_caps);
    operations_research::CVRPTWSolver vrpSolver;

    std::vector<std::vector<int64>> cvrp_result = vrpSolver.SolveCVRP(matrix, veh_caps.size(), lns, tm);





    for(int i=0; i< cvrp_result.size(); i++) {

      _return.push_back(std::vector<int64_t>(0,0));
      for (int j = 0; j < cvrp_result[i].size(); j++){

        _return[i].push_back((int64_t) cvrp_result[i][j]);
      }
    }



    printf("solveCVRP\n");
  }

  void solveCVRPTW(std::vector<std::vector<int64_t> > & _return, const std::vector<std::vector<int64_t> > & vec, const std::vector<int64_t> & demands, const std::vector<int64_t> & v_caps, const std::vector<std::vector<int64_t> > & timeWindows, const std::vector<int64_t> & serviceTime, const int64_t lns, const int64_t tm) {


    Utils utils;




    int size = vec.size();
    int demandSize  = demands.size();
    int servTimes = serviceTime.size();

    std::vector<long long int> v2 (size, 0);
    std::vector<long long int> dem (demandSize, 0);
    std::vector<long long int> veh_caps(v_caps.size(),0);
    std::vector<long long int > sTime(servTimes, 0);

    std::vector<std::vector<long long int>> tempVec(size, v2);

    for(int i=0; i< tempVec.size(); i++) {
      for (int j=0;j<tempVec[i].size(); j++){

        tempVec[i][j] = (long long int) vec[i][j];
        // std::cout << tempVec[i][j] << " ";
      }
      // std::cout << std::endl;
    }


    for(int i=0; i< demandSize; i++) {

      dem[i] = demands[i];
    }


    for(int i=0; i< v_caps.size(); i++) {

      veh_caps[i] = v_caps[i];
    }


    for(int i=0; i< servTimes; i++) {

      sTime[i] = serviceTime[i] ;
      //
      // std::cout <<  sTime[i] << std::endl;
    }



    // std::vector<std::vector<int64>> tempVec = utils.cast2dList(vec);
    // std::vector<int64> dem = utils.castList(demands);
    // std::vector<int64> veh_caps = utils.castList(v_caps);


    std::vector<std::pair<int64, int64>> timeW = utils.castToListOfPairs(timeWindows);
    // std::vector<int64> servTime = utils.castList(serviceTime);

    operations_research::Matrix matrix(tempVec, dem, veh_caps, timeW, sTime);
    operations_research::CVRPTWSolver vrpSolver;

    std::vector<std::vector<int64>> cvrp_result = vrpSolver.SolveCVRPTW(matrix, veh_caps.size(), lns, tm);

    for(int i=0; i< cvrp_result.size(); i++) {

      _return.push_back(std::vector<int64_t>(0,0));
      for (int j = 0; j < cvrp_result[i].size(); j++){

        _return[i].push_back((int64_t) cvrp_result[i][j]);
      }
    }







    printf("solveCVRPTW\n");
  }

  void solveCVRPTWMD(std::vector<std::vector<int64_t> > & _return, const std::vector<std::vector<int64_t> > & vec, const std::vector<int64_t> & demands, const std::vector<int64_t> & v_caps, const std::vector<std::vector<int64_t> > & timeWindows, const std::vector<int64_t> & serviceTime, const std::vector<std::vector<int64_t> > & depots, const int64_t lns, const int64_t tm) {


    Utils utils;




    int size = vec.size();
    int demandSize  = demands.size();
    int servTimes = serviceTime.size();

    std::vector<long long int> v2 (size, 0);
    std::vector<long long int> dem (demandSize, 0);
    std::vector<long long int> veh_caps(v_caps.size(),0);
    std::vector<long long int > sTime(servTimes, 0);


    std::vector<std::vector<long long int>> tempVec(size, v2);

    for(int i=0; i< tempVec.size(); i++) {
      for (int j=0;j<tempVec[i].size(); j++){

        tempVec[i][j] = (long long int) vec[i][j];
        // std::cout << tempVec[i][j] << " ";
      }
      // std::cout << std::endl;
    }


    for(int i=0; i< demandSize; i++) {

      dem[i] = demands[i];
    }


    for(int i=0; i< v_caps.size(); i++) {

      veh_caps[i] = v_caps[i];
    }


    for(int i=0; i< servTimes; i++) {

      sTime[i] = serviceTime[i] ;
      //
      // std::cout <<  sTime[i] << std::endl;
    }



    // std::vector<std::vector<int64>> tempVec = utils.cast2dList(vec);
    // std::vector<int64> dem = utils.castList(demands);
    // std::vector<int64> veh_caps = utils.castList(v_caps);


    std::vector<std::pair<int64, int64>> timeW = utils.castToListOfPairs(timeWindows);
    std::vector<std::pair<int64, int64>> deps = utils.castToListOfPairs(depots);

    std::vector<std::pair<operations_research::RoutingModel::NodeIndex, operations_research::RoutingModel::NodeIndex>> newDeps(deps.size());



    for ( int i = 0; i < deps.size(); i++){


      newDeps[i] = std::make_pair(deps.at(i).first, deps.at(i).second);

    }


    // std::vector<int64> servTime = utils.castList(serviceTime);

    operations_research::Matrix matrix(tempVec, dem, veh_caps, timeW, sTime);
    operations_research::CVRPTWSolver vrpSolver;

    std::vector<std::vector<int64>> cvrp_result = vrpSolver.SolveCVRPTWMD(matrix, veh_caps.size(), newDeps, lns, tm);

    for(int i=0; i< cvrp_result.size(); i++) {

      _return.push_back(std::vector<int64_t>(0,0));
      for (int j = 0; j < cvrp_result[i].size(); j++){

        _return[i].push_back((int64_t) cvrp_result[i][j]);
      }
    }




    printf("solveCVRPTWMD\n");
  }

  void solveCVRPTWPD(std::vector<std::vector<int64_t> > & _return, const std::vector<std::vector<int64_t> > & vec, const std::vector<int64_t> & demands, const std::vector<int64_t> & v_caps, const std::vector<std::vector<int64_t> > & timeWindows, const std::vector<int64_t> & serviceTime, const std::vector<int64_t> & pickups, const std::vector<int64_t> & delivs, const int64_t lns, const int64_t tm) {

    Utils utils;




    int size = vec.size();
    int demandSize  = demands.size();
    int servTimes = serviceTime.size();

    std::vector<long long int> v2 (size, 0);
    std::vector<long long int> dem (demandSize, 0);
    std::vector<long long int> veh_caps(v_caps.size(),0);
    std::vector<long long int > sTime(servTimes, 0);
    std::vector<operations_research::RoutingModel::NodeIndex> picks(pickups.size(), operations_research::RoutingModel::NodeIndex(0) );
    std::vector<operations_research::RoutingModel::NodeIndex> dels(delivs.size(), operations_research::RoutingModel::NodeIndex(0));


    std::vector<std::vector<long long int>> tempVec(size, v2);

    for(int i=0; i< tempVec.size(); i++) {
      for (int j=0;j<tempVec[i].size(); j++){

        tempVec[i][j] = (long long int) vec[i][j];
        // std::cout << tempVec[i][j] << " ";
      }
      // std::cout << std::endl;
    }


    for(int i=0; i< demandSize; i++) {

      dem[i] = demands[i];
    }


    for(int i=0; i< v_caps.size(); i++) {

      veh_caps[i] = v_caps[i];
    }


    for(int i=0; i< servTimes; i++) {

      sTime[i] = serviceTime[i] ;
      //
      // std::cout <<  sTime[i] << std::endl;
    }

    for(int i=0; i< pickups.size(); i++) {

      picks[i] = operations_research::RoutingModel::NodeIndex(pickups[i]) ;
      //
      // std::cout <<  sTime[i] << std::endl;
    }


    for(int i=0; i< delivs.size(); i++) {

      dels[i] = operations_research::RoutingModel::NodeIndex (delivs[i]) ;
      //
      // std::cout <<  sTime[i] << std::endl;
    }



    // std::vector<std::vector<int64>> tempVec = utils.cast2dList(vec);
    // std::vector<int64> dem = utils.castList(demands);
    // std::vector<int64> veh_caps = utils.castList(v_caps);


    std::vector<std::pair<int64, int64>> timeW = utils.castToListOfPairs(timeWindows);

    operations_research::Matrix matrix(tempVec, dem, veh_caps, timeW, sTime);
    operations_research::CVRPTWSolver vrpSolver;


    std::vector<std::vector<int64>> cvrp_result = vrpSolver.SolveCVRPTWPD(matrix, veh_caps.size(), picks, dels, lns, tm);

    for(int i=0; i< cvrp_result.size(); i++) {

      _return.push_back(std::vector<int64_t>(0,0));
      for (int j = 0; j < cvrp_result[i].size(); j++){

        _return[i].push_back((int64_t) cvrp_result[i][j]);
      }
    }




    printf("solveCVRPTWPD\n");
  }

};

int main(int argc, char **argv) {
  int port = 9090;

  shared_ptr<VRPSolverHandler> handler(new VRPSolverHandler());
  shared_ptr<TProcessor> processor(new VRPSolverProcessor(handler));
  shared_ptr<TProtocolFactory> protocolFactory(new TBinaryProtocolFactory());

  // using thread pool with maximum 15 threads to handle incoming requests
  shared_ptr<ThreadManager> threadManager = ThreadManager::newSimpleThreadManager(15);
  shared_ptr<PosixThreadFactory> threadFactory = shared_ptr<PosixThreadFactory>(new PosixThreadFactory());
  threadManager->threadFactory(threadFactory);
  threadManager->start();
  TNonblockingServer server(processor, protocolFactory, port, threadManager);
  std::cout << "listening..." << std::endl;
  server.serve();
  return 0;

}

